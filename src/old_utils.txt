use regex::Regex;
use std::io::{self, Write};
use std::path::PathBuf;
use std::process::{Command as ProcessCommand, Stdio};
use std::{fs, process};

use crate::{PEN_DIR, PYTHON_VERSIONS_DIR};

pub fn is_major_minor(py_version: &str) -> bool {
    let re = Regex::new(r"^\d+\.\d+$").expect("Invalid regex");
    return re.is_match(&py_version);
}

pub fn is_major_minor_patch(py_version: &str) -> bool {
    let re = Regex::new(r"^\d+\.\d+\.\d+$").expect("Invalid regex");
    return re.is_match(&py_version);
}

pub fn get_version_path(py_full_version: &str) -> PathBuf {
    let py_version_dir_name = format!("python_{}", py_full_version);
    return PYTHON_VERSIONS_DIR.join(py_version_dir_name);
}

pub fn ask_for_confirmation(prompt: &str) -> bool {
    println!("{}", prompt);

    // Flush stdout to ensure the prompt appears before reading input
    io::stdout().flush().unwrap();

    // Read user input
    let mut user_input = String::new();
    io::stdin().read_line(&mut user_input).unwrap();

    return user_input.trim().eq_ignore_ascii_case("y");
}

// todo py_patch_version name makes it seems like it means only the last part of the version
pub fn get_install_algorithm_version(py_patch_version: &str) -> u8 {
    if !is_major_minor_patch(py_patch_version) {
        eprintln!(
            "Failed to get install algorithm version, format of py_patch_version is incorrect."
        );
        process::exit(1);
    }
    let pos = py_patch_version.rfind(".").unwrap();
    let py_minor_version = py_patch_version[..pos].to_string();

    let latest_minor_file = PEN_DIR
        .join("python_versions_info")
        .join(&py_minor_version)
        .join(&py_patch_version);

    if !latest_minor_file.exists() || !latest_minor_file.is_file() {
        eprintln!(
            "This version has no install algorithm defined, are you sure this version exists?"
        );
        process::exit(1);
    }

    let install_algorithm_version_string = fs::read_to_string(&latest_minor_file).expect(&format!(
        "Failed to read file: {}",
        &latest_minor_file.display()
    ));

    return install_algorithm_version_string.parse::<u8>().unwrap(); // todo don't use unwrap, catch error
}

pub fn get_latest_py_patch_version(py_minor_version: &str) -> String {
    let latest_patch_file = PEN_DIR
        .join("python_versions_info")
        .join(&py_minor_version)
        .join("latest_patch.txt");

    if !latest_patch_file.exists() || !latest_patch_file.is_file() {
        eprintln!("The latest patch version has not yet been determined. Try updating pen.");
        process::exit(1);
    }

    let latest_py_patch_version = fs::read_to_string(&latest_patch_file).expect(&format!(
        "Failed to read file: {}",
        &latest_patch_file.display()
    ));

    if !is_major_minor_patch(&latest_py_patch_version) {
        eprintln!("Failed to get latest patch version, version format found is incorrect.");
        process::exit(1);
    }

    return latest_py_patch_version;
}

pub fn download_file(url: &str, file_path: &PathBuf) {
    // Continue with the actual download
    let download_output = ProcessCommand::new("curl")
        .stdin(Stdio::null())
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .arg("-4")
        .arg("-s")
        .arg("-o")
        .arg(file_path)
        .arg("-L")
        .arg(url)
        .output();

    // Check if download was successful
    match download_output {
        Ok(_) => {
            if file_path.exists() {
                return;
            } else {
                eprintln!("Downloaded file was not found.");
                process::exit(1);
            }
        }
        Err(e) => {
            eprintln!("Error executing curl command to download file: {}", e);
            process::exit(1);
        }
    }
}
